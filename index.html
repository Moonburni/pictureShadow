<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>图片滤镜</title>
    <link href="css/reset.css" rel="stylesheet" type="text/css">
    <link href="css/base.css" rel="stylesheet" type="text/css">
    <link href="css/index.css" rel="stylesheet" type="text/css">
</head>
<body>
<div id="box1">
    <h1>展示台</h1>
    <div id="platform">
        <div id="imgBox">
            <canvas id="imgCanvas"></canvas>
        </div>
        <div id="btnBox">
            <div class="uploadImg">
                <input type="file" accept="image/*" onchange="getPicture(this)"/>
                <div class="uploadBackground">点击上传照片</div>
            </div>
            <div onclick="downloadPicture()" class="baseBtn">下载图片</div>
        </div>
    </div>
</div>
<div id="box2">
    <h1>操作台</h1>
    <div id="selectBox">
        <h2>基础设置</h2>
        <label>灰度
            <input type="range" title="灰度" onchange="changeNum('grey', this)" min="0" max="100" value="0" step="1"/>
        </label>
        <label>模糊
            <input type="range" title="模糊" onchange="changeNum('blur', this)" min="0" max="5" value="0" step="0.05"/>
        </label>
        <label>对比度
            <input type="range" title="对比度" onchange="changeNum('contrast', this)" min="100" max="1000" value="0"
                   step="10"/>
        </label>
        <label>色系反转
            <input type="range" title="色相反转" onchange="changeNum('hue-rotate', this)" min="0" max="180" value="0"
                   step="1"/>
        </label>
        <label>反色
            <input type="range" title="反色" onchange="changeNum('invert', this)" min="0" max="180" value="0" step="1"/>
        </label>
        <label>褐色
            <input type="range" title="褐色" onchange="changeNum('sepia', this)" min="0" max="180" value="0" step="1"/>
        </label>
        <label>饱和度
            <input type="range" title="饱和度" onchange="changeNum('saturate', this)" min="0" max="200" value="0"
                   step="2"/>
        </label>
        <label>透明度
            <input type="range" title="透明度" onchange="changeNum('opacity', this)" min="0" max="100" value="0" step="1"/>
        </label>
        <label>亮度
            <input type="range" title="亮度" onchange="changeNum('brightness', this)" min="0" max="200" value="0"
                   step="2"/>
        </label>
        <h2>其他</h2>
        <div onclick="clearNum()" class="baseBtn">重置</div>
        <div onclick="cutImg()" class="baseBtn">剪裁</div>
    </div>
</div>
</body>
<script>
    const img_id = 'picture';
    let img = null;
    let canvasImg = document.getElementById('imgCanvas');

    let cutImg = (function () {
        let imgBox = document.getElementById('imgBox');
        let canvas = null;
        return () => {
            if (canvas || !img) return;
            let create = createCanvas(canvasImg, 'cut');
            canvas = create.canvas;
            let confirm = document.createElement('div');
            let cancel = document.createElement('div');
            let cutBox = document.createElement('div');
            cutBox.className = 'cutBox';
            confirm.innerText = '✔';
            confirm.className = 'baseBtn';
            cancel.className = 'baseBtn';
            cancel.innerText = '✘';
            cutBox.appendChild(confirm);
            cutBox.appendChild(cancel);
            confirm.addEventListener('click',function () {
                cutImgChange(create.cutArea);
                imgBox.removeChild(canvas);
                imgBox.removeChild(cutBox);
                canvas = null;
            });
            cancel.addEventListener('click',function () {
                imgBox.removeChild(canvas);
                imgBox.removeChild(cutBox);
                canvas = null;
            });
            imgBox.appendChild(canvas);
            imgBox.appendChild(cutBox);
        }
    })();

    function cutImgChange(area) {
        let imgBox = document.getElementById('imgBox');
        let canvas = document.createElement('canvas');
        let content = canvas.getContext('2d');
        let rate = area.p / area.q;
        if (rate <= 1) {
            canvas.height = parseInt(getComputedStyle(imgBox).height) * 0.8;
            canvas.width = parseInt(getComputedStyle(imgBox).height) * 0.8 * rate;
        } else {
            canvas.width = parseInt(getComputedStyle(imgBox).width) * 0.8;
            canvas.height = parseInt(getComputedStyle(imgBox).width) * 0.8 / rate;
        }
        content.drawImage(img,
            (img.width*area.x/canvasImg.width) >>> 0,
            (img.height*area.y/canvasImg.height) >>> 0,
            (img.width*area.p/canvasImg.width) >>> 0,
            (img.height*area.q/canvasImg.height) >>> 0,
            0, 0, canvas.width, canvas.height);
        img.src = canvas.toDataURL(`image/png`, 0.97);
    }

    function createCanvas(img, id) {

        function getArea(content, obj) {
            content.clearRect(0, 0, canvas.width, canvas.height);
            content.fillStyle = 'rgba(0,0,0,0.6)';
            content.fillRect(0, 0, canvas.width, canvas.height);
            content.clearRect(obj.x, obj.y, obj.p, obj.q)
        }

        function judgePosition(x, y, area) {
            return (area.x <= x && x <= area.p + area.x && area.y <= y && y <= area.q + area.y);
        }

        function boundaryValueTesting(x, y, area) {
            if (Math.abs(x - area.x) < 10 && Math.abs(y - area.y) < 10) return 'nw-resize';
            if (Math.abs(x - area.x) < 10 && Math.abs(y - area.y - area.q) < 10) return 'sw-resize';
            if (Math.abs(x - area.x - area.p) < 10 && Math.abs(y - area.y) < 10) return 'ne-resize';
            if (Math.abs(x - area.x - area.p) < 10 && Math.abs(y - area.y - area.q) < 10) return 'se-resize';
            if (Math.abs(x - area.x) < 10) return 'w-resize';
            if (Math.abs(x - area.x - area.p) < 10) return 'e-resize';
            if (Math.abs(y - area.y) < 10) return 'n-resize';
            if (Math.abs(y - area.y - area.q) < 10) return 's-resize';
            return 'move'
        }

        let cutArea = {
            x: img.width * 0.25,
            y: img.height * 0.25,
            p: img.width * 0.5,
            q: img.height * 0.5
        };

        let canvasStatus = {
            canMove: false,
            canStretch: false
        };

        const canvas = document.createElement('canvas');
        canvas.width = img.width;
        canvas.height = img.height;
        if (id) canvas.id = id;
        const context = canvas.getContext('2d');
        getArea(context, cutArea);
        canvas.addEventListener('mousedown', function (event) {
            if (judgePosition(event.offsetX, event.offsetY, cutArea)) {
                canvasStatus.canMove = boundaryValueTesting(event.offsetX, event.offsetY, cutArea) === 'move';
                canvasStatus.canStretch = boundaryValueTesting(event.offsetX, event.offsetY, cutArea);
            }
        });
        canvas.addEventListener('mouseleave', function () {
            canvasStatus.canMove = false;
            canvasStatus.canStretch = false;
        });
        canvas.addEventListener('mouseup', function () {
            canvasStatus.canMove = false;
            canvasStatus.canStretch = false;
        });
        canvas.addEventListener('mousemove', function (event) {
            if (judgePosition(event.offsetX, event.offsetY, cutArea)) {
                this.style.cursor = boundaryValueTesting(event.offsetX, event.offsetY, cutArea);
            } else {
                this.style.cursor = 'default';
            }
            if (canvasStatus.canMove) {
                cutArea.x = cutArea.x + event.movementX >= 0 ? cutArea.x + event.movementX : 0;
                cutArea.x = cutArea.x >= canvas.width - cutArea.p ? canvas.width - cutArea.p : cutArea.x;
                cutArea.y = cutArea.y + event.movementY >= 0 ? cutArea.y + event.movementY : 0;
                cutArea.y = cutArea.y >= canvas.height - cutArea.q ? canvas.height - cutArea.q : cutArea.y;
                getArea(context, cutArea);
            } else if (canvasStatus.canStretch) {
                if (canvasStatus.canStretch.indexOf('n') > -1 && canvasStatus.canStretch.indexOf('n') < 3) {
                    if (cutArea.q > 1) {
                        cutArea.y = cutArea.y + event.movementY >= 0 ? cutArea.y + event.movementY : 0;
                    }
                    cutArea.q = cutArea.q - event.movementY;
                    cutArea.q = cutArea.q > 1 ? cutArea.q : 1 ;
                }
                if (canvasStatus.canStretch.indexOf('w') > -1 && canvasStatus.canStretch.indexOf('w') < 3) {
                    if (cutArea.p > 1) {
                        cutArea.x = cutArea.x + event.movementX >= 0 ? cutArea.x + event.movementX : 0;
                    }
                    cutArea.p = cutArea.p - event.movementX;
                    cutArea.p = cutArea.p > 1 ? cutArea.p : 1 ;
                }
                if (canvasStatus.canStretch.indexOf('e') > -1 && canvasStatus.canStretch.indexOf('e') < 3) {
                    cutArea.p = cutArea.p + event.movementX;
                    cutArea.p = cutArea.p > 1 ? cutArea.p : 1 ;
                }
                if (canvasStatus.canStretch.indexOf('s') > -1 && canvasStatus.canStretch.indexOf('s') < 3) {
                    cutArea.q = cutArea.q + event.movementY;
                    cutArea.q = cutArea.q > 1 ? cutArea.q : 1 ;
                }
                getArea(context, cutArea);
            }
        });
        return {
            canvas: canvas,
            cutArea: cutArea
        }
    }

    function stringAdd(oldStr, style, value) {
        if (oldStr) {
            if (oldStr.indexOf(style) >= 0) {
                let reg = new RegExp(`(.*${style}[\(])([^\)]*)([\)].*)`);
                return oldStr.replace(reg, '$1' + value + '$3');
            } else {
                return `${oldStr} ${style}(${value})`;
            }
        } else {
            return `${style}(${value})`;
        }
    }

    function getPicture(file) {
        if (file.files && file.files[0]) {
            let reader = new FileReader();
            reader.onload = function (evt) {
                if (!img) {
                    let imgBox = document.getElementById('imgBox');
                    let _img = new Image();
                    _img.onload = function () {
                        _img.id = img_id;
                        img = _img;
                        const content = canvasImg.getContext('2d');
                        let rate = _img.width / _img.height;
                        if (rate <= 1) {
                            canvasImg.height = parseInt(getComputedStyle(imgBox).height) * 0.8;
                            canvasImg.width = parseInt(getComputedStyle(imgBox).height) * 0.8 * rate;
                        } else {
                            canvasImg.width = parseInt(getComputedStyle(imgBox).width) * 0.8;
                            canvasImg.height = parseInt(getComputedStyle(imgBox).width) * 0.8 / rate;
                        }
                        content.drawImage(_img, 0, 0, canvasImg.width, canvasImg.height);
                    };
                    _img.src = evt.target.result;
                } else {
                    img.src = evt.target.result;
                }
            };
            reader.readAsDataURL(file.files[0]);
        }
    }

    function clearNum() {
        [...document.getElementById('selectBox').children]
            .map(label => label.children)
            .forEach((input) => {
                if (input[0]) input[0].value = '0';
                if (img) canvasImg.style.filter = '';
            })
    }

    function changeNum(type, e) {
        if (type === 'grey') {
            if (img) canvasImg.style.filter = stringAdd(canvasImg.style.filter, 'grayscale', `${e.value}%`);
        } else if (type === 'blur') {
            if (img) canvasImg.style.filter = stringAdd(canvasImg.style.filter, 'blur', `${e.value}px`);
        } else if (type === 'contrast') {
            if (img) canvasImg.style.filter = stringAdd(canvasImg.style.filter, 'contrast', `${e.value}%`);
        } else if (type === 'hue-rotate') {
            if (img) canvasImg.style.filter = stringAdd(canvasImg.style.filter, 'hue-rotate', `${e.value}deg`);
        } else if (type === 'invert') {
            if (img) canvasImg.style.filter = stringAdd(canvasImg.style.filter, 'invert', `${e.value}%`);
        } else if (type === 'sepia') {
            if (img) canvasImg.style.filter = stringAdd(canvasImg.style.filter, 'sepia', `${e.value}%`);
        } else if (type === 'saturate') {
            if (img) canvasImg.style.filter = stringAdd(canvasImg.style.filter, 'saturate', `${e.value}%`);
        } else if (type === 'opacity') {
            if (img) canvasImg.style.filter = stringAdd(canvasImg.style.filter, 'opacity', `${e.value}%`);
        } else if (type === 'brightness') {
            if (img) canvasImg.style.filter = stringAdd(canvasImg.style.filter, 'brightness', `${e.value}%`);
        }
    }


    function download(url, fullName) {
        const anchor = document.createElement('a');
        anchor.href = url;
        anchor.setAttribute('download', fullName);
        anchor.click();
    }

    function changeImage(canvasImg, img, format = 'png', quality = 0.97) {
        const canvas = document.createElement('canvas');
        canvas.width = canvasImg.width;
        canvas.height = canvasImg.height;
        const context = canvas.getContext('2d');
        context.filter = getComputedStyle(canvasImg).filter;
        img.setAttribute('crossOrigin', 'anonymous');
        context.drawImage(img, 0, 0, canvas.width, canvas.height);
        const url = canvas.toDataURL(`image/${format}`, quality);
        return {
            url,
            then: (cb) => {
                cb(url)
            },
            download: (name = 'image') => {
                download(url, `${name}.${format}`)
            }
        }
    }

    function downloadPicture() {
        if (img) {
            changeImage(canvasImg, img).download()
        }
    }

</script>
</html>